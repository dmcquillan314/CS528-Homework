\input{cs528_style.tex}
\usepackage{algorithm}
\usepackage{listings}
%\usepackage{algpseudocode}
\usepackage{graphicx,amssymb,amsmath}
\usepackage{epstopdf}

\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usepackage[latin1]{inputenc}
\usepackage{color}
\usepackage{listings}
\lstset{ %
language=pascal,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

\sloppy


\oddsidemargin 0in
\evensidemargin 0in
\textwidth 6.5in
\topmargin -0.5in
\textheight 9.0in

\begin{document}

\solution{Dan McQuillan}{\today}{7}{Summer 2014}{CS 528}{Object Oriented Programming and Design}

\pagestyle{myheadings}  % Leave this command alone

\begin{enumerate}
	\item[\bf{Part 0}]
	
		Click the links above and read the original blog post, and the response from Kent Beck. Then, answer the following briefly (2-3 sentences).
		
		\begin{enumerate}
			\item What are the major complaints that David brings against TDD?
			
			%answer
			That TDD was hurting the architecture/design of his applications.  TDD will lead to overly complex applications and unnecessary abstraction. He also states that we should be focusing more on the design of an application rather than the structure of our unit tests.
			
			\item What does he propose as being the solution?
			
			%answer
			His proposed solution is that we should put less emphasis on unit tests and more emphasis on system tests.  He proposes that we should move away from test first and move more in the direction of testing the responses after the fact.
			
			\item Pick two of the things Kent Beck would miss without using TDD. Can you accomplish those things without the use of TDD?
			
				\begin{enumerate}
					\item Logic errors
					
					This could be accomplished through rigorous testing of the service, but it would be easier to plan out these utilities via unit testing and the test first pattern.
					
					\item Anxiety
					
					This can be accomplished also through rigorous e2e tests, which can be very time consuming.
					
				\end{enumerate}
		\end{enumerate}	
		
	\item[\bf{Part 1}]
	
		\begin{enumerate}
			
			\item What is a Mock Object? Give an example of the use for a mock.
				
				% answer
				A mock object can be used to simulate an example instantiation of an object/class.  An example usage could be when interacting with a ReST service. For example if you have a user authentication service and you would like to test responses from the service to make sure that the correct flow is taken for a response from the service.

			\item At one point, Kent says the following:
				
				Even if I don't know how to implement something I can almost always figure out how to write a test for it. And if I can't figure out how to write a test, I have no business writing it in the first place.

				Do you agree with this sentiment? Why or why not?
				
				% answer
				I don't fully agree with this sentiment.  However, I do agree with Kent's opinion of you should have no business writing it yet.  I say yet because I believe it's more of an issue of you not understanding the problem at hand.  Not knowing how to write the unit tests is just an example of a causality of not understanding the problem.

			\item What is the "red/green/refactor" loop?
				
				% answer
				Red is after writing the tests they will failure. Then green is working on it until it works.  Once it's working it may not be in a "perfect" state so you should then refactor to clean up the code to make it more readable/reusable.  It is noted as a loop since this process should be repeated until the desired results have been reached.

			\item Which way of arriving at a test suite is better, in your opinion: "going through the tests" (test-first) or "going to the tests" (test-after)? Does it matter at all? Does this depend on the situation? (If so, in what way/ways?)
				
				% answer
				I think it depends on the situation and the task at hand.  If for example you're writing a service that acts as a utility and you fully know what needs to be implemented and all the use cases.  Then, test first may be the better option.  However, if you're working on a task that is more dependent on a third party, such as an api, where all the use cases are not clear.  Then, a mix of the two might be better.  Test first to create the necessary set up and helpers and test after to do integration and performance testing.

			\item In what cases is TDD not (easily) applicable? Give at least one example. What can you do in these cases?
				
				% answer
				An example where TDD is not easily applicable would be when using live data.  In these cases integration, service, and usability testing can be helpful.  You can also use mock objects in those cases although all the cases may not be caught and tested.

			\item In what ways can an overzealous demand for isolation in unit testing create problems? Is this inherent in unit-testing or TDD?
				
				% answer
				By having a demand for isolation you are making sure that each component works when isolated from the rest of the components.  However you are not testing these components when they are communicating with each other which can cause some edge cases to arise.  This is inherent mainly in unit testing as TDD will allows you to thoroughly analyze the problem before beginning on development.  However, it can also appear in TDD in edge cases that a developer may not expect.

			\item Why should you have an automated unit test suite? Give at least two reasons.
							
				% answer
				As the code base grows on larger projects it helps to have to test suite to make sure changes to the code do not break the core functional aspects of the application.  This can help by integrating the unit tests in the build of the application.  Another reason is because it helps to document the functionality of the component you are unit testing.

		\end{enumerate}
	
	\item[\bf{Part 2}]
	
		\begin{enumerate}
			\item What is an MVC application? Where did this design pattern originate?

				% answer
				A simple explanation of MVC is that you have a Model, View and Controller.  The controller manipulates the model.  The model updates the view.  When the view changes it uses and interacts with the controller.
				
				From wikipedia: \\
				MVC was one of the seminal insights in the early development of graphical user interfaces, and one of the first approaches to describe and implement software constructs in terms of their responsibilities. 
				
			\item Can an application have a worse design because of an attempt to make it more testable? Or is it the case that something that is more testable is always a better design?

				% answer
				I don't believe that an application can have a worse design if it is made more testable.  I think that if it is made more testable(using a proper testing strategy) and it is broken up into lexical modules then the design will not suffer.  However, if it is made such that it is broken up into overly simplified modules it can make the design of an application harder to understand.

			\item How does TDD influence the design of code? Give a positive and a negative example.

				% answer
				It can help a programmer to figure out a logical way to structure and separate your application into modules. A positive example could be when writing a larger application it forces you to think out the design of the application beforehand.  However, a negative example is based on the same reason.  Since you have to think out the design of the application, you will be breaking up your application into unit testable components.  For example, if you are writing a simple Customer class you might have to then write an interface, a mock class, some IoC configuration and then tests for each.

			\item David correlates the size of a codebase with how easy it is to change it. Does this correlation ring true, in your experience?

				% answer
				I think that it depends on the situation.  In some cases easy to understand and change code can be written in a few lines when the problem at hand is simple.  However, for larger applications a smaller size of the codebase can lessen how orthogonal the application is. 

			\item Compare the situation David brings up of "test-induced design damage" coming from a desire for isolation in TDD with the concept of "speculative generality". Are they similar? the same? why/why not?

				% answer
				They are in most cases the same.  Speculative generality can be seen when the only callers of a method are test cases.  Such methods could also be seen as test induced design damage.  Test induced design damage also has the same result since in both cases the problem is over abstracted to allow for testing every aspect of the problem in isolation.

			\item What is cohesion? What is coupling? In what ways can more of one mean less of the other?

				% answer
				Coupling is how much a module relies on another module. Cohesion is how much parts of a module belong together.  Being low coupling would mean that changing something major in one class should not affect the other. High coupling would make your code difficult to make changes as well as to maintain it, as classes are coupled closely together, making a change could mean an entire system revamp.

			\item Kent says,

			Difficulty testing is a symptom of poor design.

			Do you agree?

				% answer
				I agree with his statement since if a module is easy to test that means that it will usually have high cohesion.  This is because the higher the cohesion the larger the isolation of the module.  If a module is harder to test that could be a result of having higher coupling since it may be harder to test due to a need for mock objects to test it.

			\item Kent says he is optimistic in that he believes that there is always some design insight that exists that will result in a design that is simultaneously more easily testable as well as better structured.

			Do you share his optimism?

				% answer
				I share his optimism for the hope that a design insight will eventually let a code base's design not suffer when making a code base more testable.

		\end{enumerate}
	
	\item[\bf{Part 3}]
		
		\begin{enumerate}
			\item Martin identifies three important forms of feedback for software development. What were they, and how well is each one served by having a unit test suite?

				% answer
				\begin{enumerate}
					\item Is the software doing something useful for the user % combine with 2
						
						This works well since it will provide concrete examples of how the software is meant to be used by a given user.  However, an aspect of this feedback is how to render output  and thinking about your user's needs. This is not conducive to tests since it's more so what looks good.  It also has a lot more manual tests such as usability testing to make sure the user base will, when given a page, know what their next logical step should be.
						
					\item Making sure you don't break anything
					
						This one is test conducive since it will check your code base with a given test suite with each compile which will help to given feedback to the user if anything major has been broken.
						
					\item Is my codebase healthy
						
						This one can be test conducive but it is more reliant on writing readable code and logical modularity of the codebase.
						
				\end{enumerate}

			\item How has Quality Assurance (QA) for programming changed over time? In particular, what role did TDD and self-testing code play in this change?

				% answer
				It has more so evolved to using TDD and gaining an aspect of overconfidence.  This has created a thought that QA was not necessary and has led to some companies removing their QA process before the release of the software.

			\item What does David mean when he refers to "criticality"? How should the "criticality" of your software influence your testing?

				% answer
				The criticality refers to the importance of the software being built and what would be lost if it did not fully function.  The criticality should influence test need for extensive testing.  The higher the criticality the more focus should be placed on testing.

			\item Describe how it's possible for code with 100\% test coverage with all tests passing can still have bugs.

				% answer
				When a software is pushed into the "wild" and the users start using it.  A user can sometimes do things that no one could ever imagine or even plan for because you had thought that the flow was so ridiculous and no one would ever do that.  It can often be hard to plan for those cases.

		\end{enumerate}
		
	\item[\bf{Part 4}]
		
		\begin{enumerate}
			\item Kent mentions a good measure for understanding how important a given test is for a codebase. What is it? How could you determine its value for a given test? Using this measure, how could you numerically define "overtesting"?

				% answer
				He mentions the concept of delta coverage.  If you have the exact same behavior in other places and multiple tests supply coverage for that case then the value for the new test is lessened.  Using this measure if the there is no confidence gained from the value of delta coverage then the test should not be added.

			\item Describe Martin's trick used to identify if a given line of code is tested by the current test suite.

				% answer
				Remove the line of code and see if a test break.
				

			\item How is the ratio of functional code to test code influenced by coupling in the system?

				% answer
				 The ratio is directly proportionate to the coupling in the system.  If the coupling in the system goes up then so would the ration.  Conversely, if the coupling goes down and the code base gets more cohesive then the ration should also go down.

			\item What are the symptoms of overtested code? undertested code?

				% answer
				You don't have enough tests if when you are changing the code you don't feel confident that it won't break because of the code which is considered under testing.  Over testing is more focused on whether or not you're spending more time writing tests than you are writing production code.

			\item How does the "audience" of a codebase change its testing tradeoffs?

				% answer
				When handing off to a team of developers it causes the development team to become more paranoid that it is going to have significant issues.  However, when handing the software off to a business team might result in having less test coverage since some developers may feel that they will be more confined to specific use cases.  Because of this, the audience can have a direct correlation to the testing coverage of the codebase.

			\item Describe the difference between placing unit tests as the "authority" of the system differs from placing the functional code as the "authority" of the system. Which places a larger focus on refactoring?

				% answer
				When the tests are the authority of the system that means that when someone is looking at the codebase they should find the most clarity in what the system should do by looking at the tests.  When the functional code is the authority, it means that you should look at the production code to interpolate what it should be doing.  The functional code as the authority places a larger focus on refactoring.

			\item What is one situation where you would be more happy to lose the tests and keep the code? What is one situation where you would be more happy to lose the code and keep the tests? What is different about these two situations?

				% answer
				Lose tests: \\
				If the tests are no longer sufficient the currently design of the system and are need of refactoring to create a better test of what the system should do.
					
				Lose code: \\
				If a system is being upgraded than the code is likely to be mostly deprecated so it would be better to remove the code.
				
				
				What's different: \\
				When losing the tests I believe it is more focused on how the system is designed and how it changes over time.  Losing the code is more reliant on the design staying consistent over the life of the codebase.

			\item David thinks the testing battle has been won, and Martin isn't so convinced. Do you believe that we've "won" the battle to get people to unit test their code? Why or why not?

				% answer
				Yes, I believe that we've won the battle to get people to unit test their code.  It is seen as good practice to unit test in order to gain confidence that a codebase is healthy.  It also helps to explain to new developers what the code is meant to do if the tests are seen as a greater authority than the production code. However, although unit testing seems to have won the battle it does not directly follow that people will use it given a set of circumstances.  Any number of excuses for a developer not to use unit testing in a project can be used.  For example, one of the common excuses I've heard is that there is not enough time to create unit testable code and also the unit tests for it.

		\end{enumerate}

\end{enumerate}

\end{document}

